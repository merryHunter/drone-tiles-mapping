# generated by openai

import numpy as np
import matplotlib.pyplot as plt


class KalmanFilter2D:
    def __init__(self, initial_state, initial_covariance, process_noise, measurement_noise):
        # Initial state estimate
        self.x = np.array(initial_state, dtype=np.float64).reshape(2, 1)
        
        # Initial covariance estimate
        self.P = np.array(initial_covariance, dtype=np.float64).reshape(2, 2)
        
        # Process noise covariance matrix
        self.Q = np.array(process_noise, dtype=np.float64).reshape(2, 2)
        
        # Measurement noise covariance matrix
        self.R = np.array(measurement_noise, dtype=np.float64).reshape(2, 2)
        
        # State transition matrix
        self.F = np.array([[1, 0], [0, 1]], dtype=np.float64)
        
        # Control input matrix
        self.B = None
        
        # Control input vector
        self.u = None
        
        # Measurement matrix
        self.H = np.array([[1, 0], [0, 1]], dtype=np.float64)
        
        # Measurement vector
        self.z = None

    def predict(self):
        # Predict the state estimate using the state transition matrix and control input vector
        self.x = np.dot(self.F, self.x) + np.dot(self.B, self.u) if self.B is not None and self.u is not None else np.dot(self.F, self.x)
        
        # Predict the covariance estimate using the process noise covariance matrix
        self.P = np.dot(np.dot(self.F, self.P), self.F.T) + self.Q

    def update(self, measurement):
        # Set the measurement vector
        self.z = np.array(measurement, dtype=np.float64).reshape(2, 1)
        
        # Calculate the Kalman gain
        K = np.dot(np.dot(self.P, self.H.T), np.linalg.inv(np.dot(np.dot(self.H, self.P), self.H.T) + self.R))
        
        # Update the state estimate using the measurement vector and Kalman gain
        self.x = self.x + np.dot(K, self.z - np.dot(self.H, self.x))
        
        # Update the covariance estimate using the measurement vector, Kalman gain, and measurement noise covariance matrix
        self.P = np.dot((np.identity(2) - np.dot(K, self.H)), self.P)


if __name__ == "__main__":
    # Define the true initial state of the object
    true_initial_state = [0, 0]

    # Define the initial state estimate of the object (unknown to the Kalman filter)
    initial_state_estimate = [0, 0]

    # Define the initial covariance estimate of the object (unknown to the Kalman filter)
    initial_covariance_estimate = [1, 0, 0, 1]

    # Define the process noise covariance matrix
    process_noise_covariance = [0.1, 0, 0, 0.1]

    # Define the measurement noise covariance matrix
    measurement_noise_covariance = [1, 0, 0, 1]

    # Create a KalmanFilter2D object with the defined parameters
    kf = KalmanFilter2D(initial_state_estimate, initial_covariance_estimate, process_noise_covariance, measurement_noise_covariance)

    # Define the true state of the object as it moves through the 2D coordinate system
    true_states = np.array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6]])

    # Define the measurements of the object as it moves through the 2D coordinate system (with added noise)
    measurements = true_states + np.random.normal(scale=1, size=true_states.shape)

    # Run the Kalman filter on the measurements to estimate the state of the object at each time step
    estimated_states = []
    for measurement in measurements:
        kf.predict()
        kf.update(measurement)
        estimated_states.append(kf.x.flatten())

    # Plot the true states, measurements, and estimated states of the object
    plt.plot(true_states[:, 0], true_states[:, 1], 'r-', label='True States')
    plt.plot(measurements[:, 0], measurements[:, 1], 'g.', label='Measurements')
    plt.plot(np.array(estimated_states)[:, 0], np.array(estimated_states)[:, 1], 'b-', label='Estimated States')
    plt.legend()
    plt.show()
